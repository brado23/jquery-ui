(function ($) {
	$.observable = function( data, options ) {
		return $.isArray( data )
			? new ObservableArray( data )
			: new ObjectObservable( data );
	};

	var ObjectObservable = function( data ) {
		if ( !this.data ) {
			return new ObjectObservable( data );
		}

		this._data = data;
		return this;
	};

	$.observable.Object = ObjectObservable;

	ObjectObservable.prototype = {
		_data: null,

		data: function() {
			return this._data;
		},

		setField: function( path, value ) { 
			if ( $.isArray( path ) ) {
				// This is the array format generated by serializeArray.
				// TODO: We've discussed an "objectchange" event to capture all N field updates here.
				for ( var i = 0; i < path.length; i++ ) {
					var pair = path[i];
					this.setField( pair.name, pair.value );
				}
			} else if ( typeof( path ) === "object" ) {
				// Object representation where field name is path and field value is value.
				// TODO: We've discussed an "objectchange" event to capture all N field updates here.
				for ( var key in path ) {
					this.setField( key, path[ key ])
				}
			} else {
				// Simple single field case.
				var object = this._data,
					args = [],
					leaf = getLeafObject( object, path );

				path = leaf[1];
				leaf = leaf[0];
				if ( leaf && (leaf[ path ] !== value )) {
					leaf[ path ] = value;
					$( object ).triggerHandler( "propertyChange", { path: path, value: value } );
				}
			}
			return this; 
		} 
	};

	function getLeafObject( object, path ) {
		if ( object && path ) {
			var parts = path.split(".");

			path = parts.pop();
			while ( object && parts.length ) {
				object = object[ parts.shift() ];
			}
			return [ object, path ];
		}
		return [];
	};

	var ObservableArray = function( data ) {
		if ( !this.data ) {
			return new ObservableArray( data );
		}

		this._data = data;
		return this;
	};

	$.observable.Array = ObservableArray;

	ObservableArray.prototype = {
		_data: null,

		data: function() {
			return this._data;
		},

		insert: function( index ) {
			var items = Array.prototype.slice.call( arguments, 1 );
			if ( items.length > 0 ) {
				Array.prototype.splice.apply( this._data, [ index, 0 ].concat( items ) );
				this._triggerEvent( { change: "insert", index: index, items: items } );
			}
		},

		remove: function( index, numToRemove ) {
			numToRemove = ( numToRemove === undefined || numToRemove === null ) ? 1 : numToRemove;
			if ( numToRemove ) {
				var items = this._data.slice( index, index + numToRemove );
				this._data.splice( index, numToRemove );
				this._triggerEvent( { change: "remove", index: index, items: items } );
			}
		},

		move: function( oldIndex, newIndex, numToMove ) {
			numToMove = ( numToMove === undefined || numToMove === null ) ? 1 : numToMove;
			if ( numToMove ) {
				var items = this._data.slice( oldIndex, oldIndex + numToMove );
				var observable = $.observable( this._data );
				this._triggerEvent( { change: "move", oldIndex: oldIndex, newIndex: newIndex, items: items } );
			}
		},

		refresh: function( newItems ) {
			Array.prototype.splice.apply( this._data, [ 0, this._data.length ].concat( newItems ) );
			this._triggerEvent( { change: "refresh" } );
		},

		_triggerEvent: function( data ) {
			$( [ this._data ] ).triggerHandler( "arrayChange", data );
		}
	};

})(jQuery);

