(function ($) {
	var observableFactoryKey = "__observableFactory__";  // TODO: Uniquify further?

	$.observable = function( data, options ) {
		var factory = $.data( data, observableFactoryKey ),
			useDefault = options && !!options.useDefault;

		if ( factory && !useDefault ) {
			return factory( data );
		} else {
			return createObservable( data );
		}
	};

	$.observable.extend = function( data, options ) {
		if ( options && $.data( data, observableFactoryKey ) ) {
			throw "Observable already extended for this data.";
		}

		var factory;
		if ( options ) {
			factory = function( data ) {
				var observable = createObservable( data );
				if ( options.before || options.after ) {
					$.each( observable, function( name, fn ) {
						if ( !( name[0] === "_" || name === "data" ) ) {
							replaceObservableFunction( observable, name, options.before, options.after, 
								function( args ) { return [ name, args ]; } );
						}
					} );
				}
				$.each( options, function( name, value ) {
					if ( !(name === "before" || name === "after") ) {
						if ( $.isFunction( value ) ) {
							observable[ name ] = value;
						} else {
							replaceObservableFunction( observable, name, value.before, value.after );
						}
					}
				} );
				return observable;
			};
		}

		$.data( data, observableFactoryKey, factory );
	}

	var ObjectObservable = function( data ) {
		if ( !this.data ) {
			return new ObjectObservable( data );
		}

		this._data = data;
		return this;
	};

	$.observable.Object = ObjectObservable;

	ObjectObservable.prototype = {
		_data: null,

		data: function() {
			return this._data;
		},

		setProperty: function( path, value ) { 
			if ( $.isArray( path ) ) {
				// This is the array format generated by serializeArray.
				// TODO: We've discussed an "objectchange" event to capture all N property updates here.
				for ( var i = 0; i < path.length; i++ ) {
					var pair = path[i];
					this.setProperty( pair.name, pair.value );
				}
			} else if ( typeof( path ) === "object" ) {
				// Object representation where property name is path and property value is value.
				// TODO: We've discussed an "objectchange" event to capture all N property updates here.
				for ( var key in path ) {
					this.setProperty( key, path[ key ])
				}
			} else {
				// Simple single property case.
				var object = this._data,
					args = [],
					leaf = getLeafObject( object, path );

				path = leaf[1];
				leaf = leaf[0];
				if ( leaf && (leaf[ path ] !== value )) {
					leaf[ path ] = value;
					$( object ).triggerHandler( "propertyChange", { path: path, value: value } );
				}
			}
			return this; 
		} 
	};

	function getLeafObject( object, path ) {
		if ( object && path ) {
			var parts = path.split(".");

			path = parts.pop();
			while ( object && parts.length ) {
				object = object[ parts.shift() ];
			}
			return [ object, path ];
		}
		return [];
	};

	var ObservableArray = function( data ) {
		if ( !this.data ) {
			return new ObservableArray( data );
		}

		this._data = data;
		return this;
	};

	$.observable.Array = ObservableArray;

	ObservableArray.prototype = {
		_data: null,

		data: function() {
			return this._data;
		},

		insert: function( index ) {
			var items = Array.prototype.slice.call( arguments, 1 );
			if ( items.length > 0 ) {
				Array.prototype.splice.apply( this._data, [ index, 0 ].concat( items ) );
				this._triggerEvent( { change: "insert", index: index, items: items } );
			}
		},

		remove: function( index, numToRemove ) {
			numToRemove = ( numToRemove === undefined || numToRemove === null ) ? 1 : numToRemove;
			if ( numToRemove ) {
				var items = this._data.slice( index, index + numToRemove );
				this._data.splice( index, numToRemove );
				this._triggerEvent( { change: "remove", index: index, items: items } );
			}
		},

		move: function( oldIndex, newIndex, numToMove ) {
			numToMove = ( numToMove === undefined || numToMove === null ) ? 1 : numToMove;
			if ( numToMove ) {
				var items = this._data.slice( oldIndex, oldIndex + numToMove );
				var observable = $.observable( this._data );
				this._triggerEvent( { change: "move", oldIndex: oldIndex, newIndex: newIndex, items: items } );
			}
		},

		refresh: function( newItems ) {
			Array.prototype.splice.apply( this._data, [ 0, this._data.length ].concat( newItems ) );
			this._triggerEvent( { change: "refresh" } );
		},

		_triggerEvent: function( data ) {
			$( [ this._data ] ).triggerHandler( "arrayChange", data );
		}
	};

	function createObservable( data ) {
		return $.isArray( data )
			? new ObservableArray( data )
			: new ObjectObservable( data );
		// To handle non-Array-typed collections, we could allow developers to
		// customize this logic.
	};

	function replaceObservableFunction( observable, name, beforeFn, afterFn, getArguments ) {
		var baseFn = observable[ name ];
		observable[ name ] = function() {
			var args = getArguments ? getArguments( arguments ) : arguments;
			if ( beforeFn ) {
				beforeFn.apply( observable, args );
			}
			baseFn.apply( observable, arguments );
			if ( afterFn ) {
				afterFn.apply( observable, args );
			}
		};
	};

})(jQuery);

